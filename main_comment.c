#include <stdio.h> //стандартный заголовочный файл ввода-вывода
#include <stdlib.h> //заголовочный файл стандартной библиотеки
#include <windows.h> //заголовочный файл для паботы shellexecute
#include <ShellApi.h> //заголовочный файл для паботы shellexecute
#define swap(x,y) {int t = a; a = b; b = t;} //макрос, меняет местами значения переменных 
int main(void){

	int rebro_count = 0; //счетчик числа ребер графа
	int node_count = 0;	//счетчик числа вершин графа
	int a = 0, b = 0;  // переменные, которые будем считывать 
	int link[255];		//массив для проверки связности графа, максимум 255 вершин
	for (int i = 0; i < 255; i++) //в цикле заполняем массив "-1",
		link[i] = -1;

	FILE *S1; //объявляем структуру типа файл,
	S1 = fopen("S1.txt", "w"); //открываем файл для записи, если его нет - создаем новый
								//т.к. путь не указан, файл находится в той же директории, что и программа
	fprintf(S1, "%s\n", "graph My_graph {"); //записываем в файл первую строку для работы graphiz

		while(scanf("%d-%d", &a, &b) != 0){ //в цикле читаем из терминала, пока scanf не вернет "0",
											//что означает, что ему не удалось считать переменные
			fprintf(S1, "%d -- %d;\n", a,b);//записываем в файл считанные вершины в соотв. с синтаксисом graphiz
			rebro_count++;					//увеличиваем счетчик ребер на 1(считали ребро)
		
			if(link[a]*link[b] < 0){		//Если а или b меньше 0, что означает, что одна вершина не встречалась, а другая уже есть
				if (a < b)					//Чтобы не писать дважды, сделаем так, чтобы a было больше b,
					swap(a,b);				//т.е. поменяем их местами, если a < b
				link[a] = link[b];			//вершине a присваиваем номер ребра b
				node_count++;				//увеличиваем счетчик вершин на 1, т.е. +1 новая вершина
			}
			else if ((link[a]*link[b] == 1)&&(link[a] != 1)){ //если ни a ни b не встречались
				link[a] = link[b] = rebro_count;				//даем им номер текущего ребра
				node_count += 2;								//и увеличиваем счетчик вершин на 2
			}
			else{									//иначе (т.е. и a и b уже встречались)
				if (a < b)
					swap(a,b);
				int find = link[a];					//запоминаем меньший номер ребра
				for (int i = 0; i < 255; i++){		// и в цикле по всему массиву заменяем все номера большего ребра на номера меньшего
					if(link[i] == find){
						link[i] = link[b];
					}
				}
			}
		}

	fprintf(S1, "%s", "}");						//записываем "}" в файл
	fclose(S1);									//закрываем файл

	int is_tree = 1;							//Пусть граф - дерево
	for(int i = 1; i <255; i++){				//Если в массиве есть номера вершин, не равные "1" - вершина соединена с корнем,
		if((link[i] != -1)&&(link[i] != 1))		//или "-1" - вершины с таким номером не существует
			is_tree = 0;						//то значит граф не связный => он не дерево
		}

	if ((node_count -(rebro_count)) != 1)		//Если число ребер не равно числу вершин +1
		is_tree = 0;							//то граф тоже не дерево	

	if (is_tree)								//Выводим результат
		printf("%s", "Граф - дерево");
	else
		printf("%s", "Граф - не дерево");

	system("dot C:/Users/serad/Documents/univer/FLAT/DZ2/S1.txt -Tbmp -o S1.bmp"); //graphiz рисует визуализацию по файлу, указать путь до файла
	ShellExecuteA(GetDesktopWindow(),"open","C:/Users/serad/Documents/univer/FLAT/DZ2/S1.bmp",NULL,NULL,SW_SHOW); //graphiz открывает картинку,
																													//указать путь до картинки
	return 0; //функция main возвращает "0", что означает, что программа завершена без ошибок
}		